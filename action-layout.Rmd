# Layout, themes, and HTML

```{r, include = FALSE}
source("common.R")
source("demo.R")
```

## Introduction

```{r}
library(shiny)
```

## Layouts {#layout}

Now that you know how to create a full range of inputs and outputs, you need to be able to arrange them on the page.
That's the job of the layout functions, which provide the high-level visual structure of an app.
Here we'll focus on `fluidPage()`, which provides the layout style used by most apps.

### Overview

Layouts are created by a hierarchy of function calls, where the hierarchy in R matches the hierarchy in the generated HTML.
When you see complex layout code like this:

```{r, eval = FALSE}
fluidPage(
  titlePanel("Hello Shiny!"),
  sidebarLayout(
    sidebarPanel(
      sliderInput("obs", "Observations:", min = 0, max = 1000, value = 500)
    ),
    mainPanel(
      plotOutput("distPlot")
    )
  )
)
```

First skim it by focusing on the hierarchy of the function calls:

```{r, eval = FALSE}
fluidPage(
  titlePanel(),
  sidebarLayout(
    sidebarPanel(
      sliderInput("obs")
    ),
    mainPanel(
      plotOutput("distPlot")
    )
  )
)
```

Even without knowing anything about the layout functions you can read the function names to guess what this app is going to look like.
You might imagine that this code will generate a classic app design: a title bar at top, followed by a sidebar (containing a slider), with the main panel containing a plot.

### Page functions

The most important, but least interesting, layout function is `fluidPage()`.
You've seen it in every example above, because we use it to put multiple inputs or outputs into a single app.
What happens if you use `fluidPage()` by itself?
Figure \@ref(fig:ui-fluid-page) shows the results.

```{r ui-fluid-page, fig.cap = "An UI consisting only of `fluidPage()`", echo = FALSE}
knitr::include_graphics("images/basic-app/fluid-page.png", dpi = 300)
```

It looks very boring because there's no content, but behind the scenes, `fluidPage()` is doing a lot of work.
The page function sets up all the HTML, CSS, and JavaScript that Shiny needs.
`fluidPage()` uses a layout system called **Bootstrap**, [<https://getbootstrap.com>](https://getbootstrap.com){.uri}, that provides attractive defaults[^action-layout-1].

[^action-layout-1]: Currently Shiny uses Bootstrap 3.3.7, <https://getbootstrap.com/docs/3.3/>, but the Shiny team is planning to update to 4.0.0, the latest version, in the near future.

Technically, `fluidPage()` is all you need for an app, because you can put inputs and outputs directly inside of it.
But while this is fine for learning the basics of Shiny, dumping all the inputs and outputs in one place doesn't look very good, so you need to learn more layout functions.
Here I'll introduce you to two common structures, a page with sidebar and a multirow app, and then we'll finish off with a quick discussion of themes.

### Page with sidebar

`sidebarLayout()`, along with `titlePanel()`, `sidebarPanel()`, and `mainPanel()`, makes it easy to create a two-column layout with inputs on the left and outputs on the right.
The basic code is shown below; it generates the structure shown in Figure \@ref(fig:ui-sidebar).

```{r, eval = FALSE}
fluidPage(
  titlePanel(
    # app title/description
  ),
  sidebarLayout(
    sidebarPanel(
      # inputs
    ),
    mainPanel(
      # outputs
    )
  )
)
```

```{r ui-sidebar, echo = FALSE, out.width = NULL, fig.cap = "Structure of a basic app with sidebar"}
knitr::include_graphics("diagrams/basic-ui/sidebar.png", dpi = 300)
```

The following example shows how to use this layout to create a very simple app that demonstrates the Central Limit Theorem.
If you run this app yourself, you can see how increasing the number of samples makes a distribution that looks very similar to a normal distribution.

```{r}
ui <- fluidPage(
  titlePanel("Central limit theorem"),
  sidebarLayout(
    sidebarPanel(
      numericInput("m", "Number of samples:", 2, min = 1, max = 100)
    ),
    mainPanel(
      plotOutput("hist")
    )
  )
)

server <- function(input, output, session) {
  output$hist <- renderPlot({
    means <- replicate(1e4, mean(runif(input$m)))
    hist(means, breaks = 20)
  }, res = 96)
}
```

```{r, echo = FALSE, out.width = "100%", message = FALSE}
demo <- demoApp$new("basic-ui/sidebar", ui, server)
demo$resize(width = 800)
demo$takeScreenshot()
```

### Multi-row

Under the hood, `sidebarLayout()` is built on top of a flexible multi-row layout, which you can use directly to create more visually complex apps.
As usual, you start with `fluidPage()`.
Then you create rows with `fluidRow()`, and columns with `column()`.
The following template generates the structure shown in Figure \@ref(fig:ui-multirow).

```{r, eval = FALSE}
fluidPage(
  fluidRow(
    column(4, 
      ...
    ),
    column(8, 
      ...
    )
  ),
  fluidRow(
    column(6, 
      ...
    ),
    column(6, 
      ...
    )
  )
)
```

```{r ui-multirow, echo = FALSE, out.width = NULL, fig.cap = "The structure underlying a simple multi-row app"}
knitr::include_graphics("diagrams/basic-ui/multirow.png", dpi = 300)
```

Note that the first argument to `column()` is the width, and the width of each row must add up to 12.
This gives you substantial flexibility because you can easily create 2-, 3-, or 4-column layouts (more than that starts to get cramped), or use narrow columns to create spacers.

### Tabsets

As your apps get more complicated, you might find that there's no way to fit all the inputs and output on to a single page.
That's where `tabsetPanel()` and its close friend `tabPanel()` come in: these allow to you spread your content across multiple panels.
As you can see in the code below, `tabsetPanel()` creates a container for any number of `tabPanels()`, which can contain any HTML components described above.

```{r}
ui <- fluidPage(
  tabsetPanel(
    tabPanel("Import data", 
      fileInput("file", "Data", buttonLabel = "Upload..."),
      textInput("delim", "Delimiter (leave blank to guess)", ""),
      numericInput("skip", "Rows to skip", 0, min = 0),
      numericInput("rows", "Rows to preview", 10, min = 1)
    ),
    tabPanel("Set parameters"),
    tabPanel("Visualise results")
  )
)
```

```{r, echo = FALSE, out.width = "100%", message = FALSE}
demo <- demoApp$new("basic-ui/tabset", ui)
demo$resize(width = 800)
demo$takeScreenshot()
```

If you want to know what tab a user has selected, you can provide the `id` argument to `tabsetPanel()` and it becomes an input:

```{r}
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textOutput("panel")
    ),
    mainPanel(
      tabsetPanel(
        id = "tabset",
        tabPanel("panel 1", "one"),
        tabPanel("panel 2", "two"),
        tabPanel("panel 3", "three")
      )
    )
  )
)
server <- function(input, output, session) {
  output$panel <- renderText({
    paste("Current panel: ", input$tabset)
  })
}
```

```{r, echo = FALSE, out.width = "50%", message = FALSE}
demo <- demoApp$new("basic-ui/tabset-input", ui, server)
demo$resize(width = 300)
demo$takeScreenshot("1")
demo$setInputs(tabset = "panel 2")
demo$takeScreenshot("2")
```

You'll see other uses for tabsets in Section \@ref(dynamic-visibility).

### Exercises

1.  Create an app with that contains two plots, each of which takes up half of the app (regardless of what size the whole app is).

Modify the Central Limit Theorem app from Section \@ref(page-with-sidebar) so that the sidebar is on the right instead of the left.

## Other tools

Other packages expose complete different design systems:

-   [shiny.semantic](https://appsilon.github.io/shiny.semantic/), by [Appsilon](https://appsilon.com/), builds on top of [formantic UI](https://fomantic-ui.com).

-   [shinyMobile](https://github.com/RinteRface/shinyMobile), by [RInterface](https://rinterface.com), builds on top of [framework 7](https://framework7.io), and is specifically designed for mobile apps.

-   [shinymaterial](https://ericrayanderson.github.io/shinymaterial/), by [Eric Anderson](https://github.com/ericrayanderson), is built on top of Google's [Material design](https://material.io/design) framework.

-   [shinydashboard](https://rstudio.github.io/shinydashboard/), also by RStudio, provides a layout system designed to create dashboards.

You can find fuller, and up-to-date, list maintained by [Nan Xiao](https://nanx.me/) at [<https://github.com/nanxstats/awesome-shiny-extensions>](https://github.com/nanxstats/awesome-shiny-extensions){.uri}.

## Themes

Shiny apps can be themed using the [bslib](https://rstudio.github.io/bslib/) package.
You can either pick an existing [bootswatch](https://bootswatch.com) theme, or design your own with the colours and fonts you want.
Either way, the basics are the same: you supply `bslib::bs_theme()` to the `theme` argument of `fluidPage()`.
Figure \@ref(fig:theme) shows the results of the following code, switching `"darkly"` out for other themes.

```{r, eval = FALSE}
ui <- fluidPage(
  theme = bslib::bs_theme(bootswatch = "darkly"),
  sidebarLayout(
    sidebarPanel(
      textInput("txt", "Text input:", "text here"),
      sliderInput("slider", "Slider input:", 1, 100, 30)
    ),
    mainPanel(
      h1(paste0("Theme: darkly")),
      h2("Header 2"),
      p("Some text")
    )
  )
)
```

```{r theme, fig.cap = "The same app styled with four bootswatch themes: darkly, flatly, sandstone, and united", echo = FALSE, out.width = "50%", fig.show="hold", fig.align='default', message = FALSE}
theme_demo <- function(theme) {
  fluidPage(
    theme = bslib::bs_theme(bootswatch = theme),
    sidebarLayout(
      sidebarPanel(
        textInput("txt", "Text input:", "text here"),
        sliderInput("slider", "Slider input:", 1, 100, 30)
      ),
      mainPanel(
        h1(paste0("Theme: ", theme)),
        h2("Header 2"),
        p("Some text")
      )
    )
  )
}

demoApp$new("basic-ui/theme-darkly", theme_demo("darkly"))$takeScreenshot()
demoApp$new("basic-ui/theme-flatly", theme_demo("flatly"))$takeScreenshot()
demoApp$new("basic-ui/theme-sandstone", theme_demo("sandstone"))$takeScreenshot()
demoApp$new("basic-ui/theme-united", theme_demo("united"))$takeScreenshot()
resourcePathReset()
```

Alternatively, you can construct your own theme using the other arguments to `bs_theme()` like `bg` (background colour), `fg` (foreground colour) and `base_font`:

```{r}
theme <- bslib::bs_theme(
  bg = "#0b3d91", 
  fg = "white",
)
```

An easy way to preview and customise your theme is to use `bslib::bs_theme_preview(theme)`.
This will open a Shiny app that shows the theme on a bunch of standard control, and provides you with interactive controls for customising the most important parameters.
I highly recommend investing a little time to learn the theming tools --- theming your app to match your corporate style guide is an easy way to make yourself look good.

### Plots

If you've heavily customised the style of your app, you may want to also customise your plots to match.
Fortunately, this is very easy thanks to the [thematic](https://rstudio.github.io/thematic/) package by Carson Sievert.
There are two main ways to use it.
Firstly, you can explicitly set a theme defined by foreground, background, and accent colours (and font if desired):

```{r, message = FALSE, warning = FALSE}
library(thematic)
thematic_on(bg = "#222222", fg = "white", accent = "#0CE3AC")

library(ggplot2)
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  geom_smooth()
```

These settings will affect all ggplot2, lattice, and base plots until you call `thematic_off()`.

You can also call `thematic_on()` with `font = "auto"` and no other arguments to attempt to automatically determine all of the settings from the theme associated with your Shiny app:

```{r, eval = FALSE}
thematic_on(font = "auto")
```

For more details, see [<https://rstudio.github.io/thematic/articles/Shiny.html>](https://rstudio.github.io/thematic/articles/Shiny.html){.uri}.

### Exercises

1.  Create an app with that contains two plots, each of which takes up half of the app (regardless of what size the whole app is).

2.  Modify the Central Limit Theorem app from Section \@ref(page-with-sidebar) so that the sidebar is on the right instead of the left.

3.  Use `bslib::bs_theme_preview()` to make the ugliest theme you can.

```{=html}
<!--

Exercise ideas

1. A sample app where some commas are missing between layout elements
1. Write the code that generates the layouts in these drawings

-->
```
## Under the hood

In the previous example you might have been surprised to see that I create a Shiny app using a function, `theme_demo()`.
This works because Shiny code **is** R code, and you can use all of your existing tools for reducing duplication.
Remember the rule of three: if you copy and paste code more than three times, you should consider writing a function or using a for loop[^action-layout-2].

[^action-layout-2]: Or using `lapply()` or `purrr::map()` if you know a little about functional programming.

All input, output, and layout functions return HTML, the descriptive language that underpins every website.
You can see that HTML by executing UI functions directly in the console:

```{r, eval = FALSE}
fluidPage(
  textInput("name", "What's your name?")
)
```

``` {.html}
<div class="container-fluid">
  <div class="form-group shiny-input-container">
    <label for="name">What's your name?</label>
    <input id="name" type="text" class="form-control" value=""/>
  </div>
</div>
```

Shiny is designed so that, as an R user, you don't need to learn about the details of HTML.
However, if you already know HTML (or want to learn!) you can also work directly with HTML tags to achieve any level of customization you want.
And these approaches are by no means exclusive: you can mix high-level functions with low-level HTML as much as you like.

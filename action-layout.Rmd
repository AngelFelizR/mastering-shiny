# Layout, themes, and HTML {#action-layout}

```{r, include = FALSE}
source("common.R")
source("demo.R")
```

## Introduction

In this chapter you'll unlock some new tools for laying out input and output components into an app, learn how to theme your app (and plots!), and learn a little bit more about how these functions work so you can customise further.

```{r}
library(shiny)
```

## Layouts {#layout}

Now that you know how to create a full range of inputs and outputs, you need to be able to arrange them on the page.
That's the job of the layout functions, which provide the high-level visual structure of an app.
Here we'll focus on `fluidPage()`, which provides the layout style used by most apps.

### Overview

Layouts are created by a hierarchy of function calls, where the hierarchy in R matches the hierarchy in the generated HTML.
When you see complex layout code like this:

```{r, eval = FALSE}
fluidPage(
  titlePanel("Hello Shiny!"),
  sidebarLayout(
    sidebarPanel(
      sliderInput("obs", "Observations:", min = 0, max = 1000, value = 500)
    ),
    mainPanel(
      plotOutput("distPlot")
    )
  )
)
```

First skim it by focusing on the hierarchy of the function calls:

```{r, eval = FALSE}
fluidPage(
  titlePanel(),
  sidebarLayout(
    sidebarPanel(),
    mainPanel()
  )
)
```

Even without knowing anything about the layout functions you can read the function names to guess what this app is going to look like.
You might imagine that this code will generate a classic app design: a title bar at top, followed by a sidebar (containing a slider), with the main panel containing a plot.

This is another reason why paying attention to the style of your code is important.
If you stick with a consistent set of rules for indenting functions, you can easily see the overall app structure in the way that your app is indented.

### Page functions

The most important, but least interesting, layout function is `fluidPage()`.
You've seen it in every example so far, because we use it to put multiple inputs or outputs into a single app.
What happens if you use `fluidPage()` by itself?
Figure \@ref(fig:ui-fluid-page) shows the results.

```{r ui-fluid-page, fig.cap = "An UI consisting only of `fluidPage()`", echo = FALSE}
knitr::include_graphics("images/action-layout/fluid-page.png", dpi = 300)
```

It looks very boring because there's no content, but behind the scenes, `fluidPage()` is doing a lot of work, setting up all the HTML, CSS, and JavaScript that Shiny needs.
`fluidPage()` uses a layout system called **Bootstrap**, [\<https://getbootstrap.com\>](https://getbootstrap.com){.uri}, that provides attractive defaults.
We'll talk more about bootstrap in Section \@ref(bootstrap).

Technically, `fluidPage()` is all you need for an app, because you can put inputs and outputs directly inside of it.
But while this is fine for learning Shiny, dumping all the inputs and outputs in one place doesn't look very good, so you need to learn more layout functions in order to generate attractive usable apps.
Here I'll introduce you to three techniques: a page with sidebar, a multirow app, and using a tabset to spread your app over multiple "pages".

### Page with sidebar

`sidebarLayout()`, along with `titlePanel()`, `sidebarPanel()`, and `mainPanel()`, makes it easy to create a two-column layout with inputs on the left and outputs on the right.
The basic code is shown below; it generates the structure shown in Figure \@ref(fig:ui-sidebar).

```{r, eval = FALSE}
fluidPage(
  titlePanel(
    # app title/description
  ),
  sidebarLayout(
    sidebarPanel(
      # inputs
    ),
    mainPanel(
      # outputs
    )
  )
)
```

```{r ui-sidebar, echo = FALSE, out.width = NULL, fig.cap = "Structure of a basic app with sidebar"}
knitr::include_graphics("diagrams/action-layout/sidebar.png", dpi = 300)
```

The following example shows how to use this layout to create a very simple app that demonstrates the Central Limit Theorem.
If you run this app yourself, you can see how increasing the number of samples makes a distribution that looks very similar to a normal distribution.

```{r}
ui <- fluidPage(
  titlePanel("Central limit theorem"),
  sidebarLayout(
    sidebarPanel(
      numericInput("m", "Number of samples:", 2, min = 1, max = 100)
    ),
    mainPanel(
      plotOutput("hist")
    )
  )
)

server <- function(input, output, session) {
  output$hist <- renderPlot({
    means <- replicate(1e4, mean(runif(input$m)))
    hist(means, breaks = 20)
  }, res = 96)
}
```

```{r, echo = FALSE, out.width = "100%", message = FALSE}
demo <- demoApp$new("action-layout/sidebar", ui, server)
demo$resize(width = 800)
demo$takeScreenshot()
```

### Multi-row

Under the hood, `sidebarLayout()` is built on top of a flexible multi-row layout, which you can use directly to create more visually complex apps.
As usual, you start with `fluidPage()`.
Then you create rows with `fluidRow()`, and columns with `column()`.
The following template generates the structure shown in Figure \@ref(fig:ui-multirow).

```{r, eval = FALSE}
fluidPage(
  fluidRow(
    column(4, 
      ...
    ),
    column(8, 
      ...
    )
  ),
  fluidRow(
    column(6, 
      ...
    ),
    column(6, 
      ...
    )
  )
)
```

```{r ui-multirow, echo = FALSE, out.width = NULL, fig.cap = "The structure underlying a simple multi-row app"}
knitr::include_graphics("diagrams/action-layout/multirow.png", dpi = 300)
```

Note that the first argument to `column()` is the width, and the width of each row must add up to 12.
This gives you substantial flexibility because you can easily create 2-, 3-, or 4-column layouts (more than that starts to get cramped), or use narrow columns to create spacers.

"[Grid systems in graphic design](https://www.amazon.com/dp/3721201450)" by Josef MÃ¼ller-Brockman.

### Tabsets

As your apps get more complicated, you might find that there's no way to fit all the inputs and output on to a single page.
That's where `tabsetPanel()` and its close friend `tabPanel()` come in: these allow to you spread your content across multiple panels.
As you can see in the code below, `tabsetPanel()` creates a container for any number of `tabPanels()`, which can contain any HTML components described above.

```{r}
ui <- fluidPage(
  tabsetPanel(
    tabPanel("Import data", 
      fileInput("file", "Data", buttonLabel = "Upload..."),
      textInput("delim", "Delimiter (leave blank to guess)", ""),
      numericInput("skip", "Rows to skip", 0, min = 0),
      numericInput("rows", "Rows to preview", 10, min = 1)
    ),
    tabPanel("Set parameters"),
    tabPanel("Visualise results")
  )
)
```

```{r, echo = FALSE, out.width = "100%", message = FALSE}
demo <- demoApp$new("action-layout/tabset", ui)
demo$resize(width = 800)
demo$takeScreenshot()
```

If you want to know what tab a user has selected, you can provide the `id` argument to `tabsetPanel()` and it becomes an input:

```{r}
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      textOutput("panel")
    ),
    mainPanel(
      tabsetPanel(
        id = "tabset",
        tabPanel("panel 1", "one"),
        tabPanel("panel 2", "two"),
        tabPanel("panel 3", "three")
      )
    )
  )
)
server <- function(input, output, session) {
  output$panel <- renderText({
    paste("Current panel: ", input$tabset)
  })
}
```

```{r, echo = FALSE, out.width = "50%", message = FALSE}
demo <- demoApp$new("action-layout/tabset-input", ui, server)
demo$resize(width = 300)
demo$takeScreenshot("1")
demo$setInputs(tabset = "panel 2")
demo$takeScreenshot("2")
```

You'll see other uses for tabsets in Section \@ref(dynamic-visibility).

### Exercises

1.  Create an app with that contains two plots, each of which takes up half of the app (regardless of what size the whole app is).

2.  Modify the Central Limit Theorem app from Section \@ref(page-with-sidebar) so that the sidebar is on the right instead of the left.

```{=html}
<!--

Exercise ideas

1. A sample app where some commas are missing between layout elements
1. Write the code that generates the layouts in these drawings

-->
```
## Bootstrap

Before we go further, it's worth briefly discussing the design framework used by Shiny: [Bootstrap](https://getbootstrap.com).
Bootstrap is a collection of HTML conventions, CSS styles, and useful JS that's been bundled in a convenient form.
Bootstrap grew out of a framework originally developed for twitter, but the core development team now comes from many places, and it has become one of the most popular CSS frameworks is use today.
In the R ecosystem bootstrap also powers `rmarkdown::html_document()` and is used by the [pkgdown](http://pkgdown.r-lib.org/) package for making package websites, so it's highly likely that you have seen many HTML documents styled with bootstrap.
All of these packages are built on a specialised package called [bslib](https://rstudio.github.io/bslib).

As a Shiny developer, you don't need to care too much about bootstrap, but knowing something about it will help you customise your app.
By default, Shiny uses bootstrap v3.
You can switch to the latest version (v4 at time of writing) with `bslib::bs_theme()`.
This will give your app a slight stylistic boost, but most importantly unlocks many more extension points which we'll discuss shortly.
Switching from v3 to v4 is 100% safe if you only use components built in to Shiny, but may require a little tweaking if your app uses custom HTML.

In the next section, I'll discuss the tools that bslib provides to change the colours and fonts used by your app.
If you want a radically different look, you may want to consider another a design framework.
A number of existing R packages make this easy by wrapping popular bootstrap alternatives:

-   [shiny.semantic](https://appsilon.github.io/shiny.semantic/), by [Appsilon](https://appsilon.com/), builds on top of [formantic UI](https://fomantic-ui.com).

-   [shinyMobile](https://github.com/RinteRface/shinyMobile), by [RInterface](https://rinterface.com), builds on top of [framework 7](https://framework7.io), and is specifically designed for mobile apps.

-   [shinymaterial](https://ericrayanderson.github.io/shinymaterial/), by [Eric Anderson](https://github.com/ericrayanderson), is built on top of Google's [Material design](https://material.io/design) framework.

-   [shinydashboard](https://rstudio.github.io/shinydashboard/), also by RStudio, provides a layout system designed to create dashboards.

You can find a fuller, actively maintained, list at [\<https://github.com/nanxstats/awesome-shiny-extensions\>](https://github.com/nanxstats/awesome-shiny-extensions){.uri}.

## Themes

I highly recommend investing a little time to learn the theming tools --- theming your app to match your corporate style guide is an easy way to make yourself look good.

```{r, eval = FALSE}
fluidPage(
  theme = bslib::bs_theme(...)
)
```

### Shiny themes

The easiest way to change the overall look of your app is to pick a premade "[bootswatch](https://bootswatch.com)" theme using the `bootswatch` argument to `bslib::bs_theme()`.
Figure \@ref(fig:theme) shows the results of the following code, switching `"darkly"` out for other themes.

```{r, eval = FALSE}
ui <- fluidPage(
  theme = bslib::bs_theme(bootswatch = "darkly"),
  sidebarLayout(
    sidebarPanel(
      textInput("txt", "Text input:", "text here"),
      sliderInput("slider", "Slider input:", 1, 100, 30)
    ),
    mainPanel(
      h1(paste0("Theme: darkly")),
      h2("Header 2"),
      p("Some text")
    )
  )
)
```

```{r theme, fig.cap = "The same app styled with four bootswatch themes: darkly, flatly, sandstone, and united", echo = FALSE, out.width = "50%", fig.show="hold", fig.align='default', message = FALSE}
theme_demo <- function(theme) {
  fluidPage(
    theme = bslib::bs_theme(bootswatch = theme),
    sidebarLayout(
      sidebarPanel(
        textInput("txt", "Text input:", "text here"),
        sliderInput("slider", "Slider input:", 1, 100, 30)
      ),
      mainPanel(
        h1(paste0("Theme: ", theme)),
        h2("Header 2"),
        p("Some text")
      )
    )
  )
}

demoApp$new("action-layout/theme-darkly", theme_demo("darkly"))$takeScreenshot()
demoApp$new("action-layout/theme-flatly", theme_demo("flatly"))$takeScreenshot()
demoApp$new("action-layout/theme-sandstone", theme_demo("sandstone"))$takeScreenshot()
demoApp$new("action-layout/theme-united", theme_demo("united"))$takeScreenshot()
```

Alternatively, you can construct your own theme using the other arguments to `bs_theme()` like `bg` (background colour), `fg` (foreground colour) and `base_font`:

```{r}
theme <- bslib::bs_theme(
  bg = "#0b3d91", 
  fg = "white"
)
```

An easy way to preview and customise your theme is to use `bslib::bs_theme_preview(theme)`.
This will open a Shiny app that shows what the theme looks like when applied many standard controls, and also provides you with interactive controls for customising the most important parameters.

### Plot themes

If you've heavily customised the style of your app, you may want to also customise your plots to match.
Fortunately, this is very easy thanks to the [thematic](https://rstudio.github.io/thematic/) package which automatically themes ggplot2, lattice, and base plots.
It's very easy to use with a Shiny app: just call `thematic_shiny()` in your server function.
This will automatically determine all of the settings from your app theme:

```{r, eval = FALSE}
thematic::thematic_shiny()
```

For more details about using thematic with Shiny, see <https://rstudio.github.io/thematic/articles/Shiny.html>.

Alternatively, if you want to theme plots outside of Shiny.
you can call `thematic::thematic_on()` with explicit: `fg` (foreground), `bg` (background), `accent`, and `font`:

```{r, message = FALSE, warning = FALSE}
thematic::thematic_on(bg = "#222222", fg = "white", accent = "#0CE3AC")

library(ggplot2)
ggplot(mtcars, aes(wt, mpg)) +
  geom_point() +
  geom_smooth()
```

These settings will affect all plots until you call `thematic_off()`.

### Exercises

1.  Use `bslib::bs_theme_preview()` to make the ugliest theme you can

## Under the hood

In the previous example you might have been surprised to see that I create a Shiny app using a function, `theme_demo()`.
This works because Shiny code **is** R code, and you can use all of your existing tools for reducing duplication.
Remember the rule of three: if you copy and paste code more than three times, you should consider writing a function or using a for loop[^action-layout-1].

[^action-layout-1]: Or using `lapply()` or `purrr::map()` if you know a little about functional programming.

All input, output, and layout functions return HTML, the descriptive language that underpins every website.
You can see that HTML by executing UI functions directly in the console:

```{r, eval = FALSE}
fluidPage(
  textInput("name", "What's your name?")
)
```

``` {.html}
<div class="container-fluid">
  <div class="form-group shiny-input-container">
    <label for="name">What's your name?</label>
    <input id="name" type="text" class="form-control" value=""/>
  </div>
</div>
```

Shiny is designed so that, as an R user, you don't need to learn about the details of HTML.
However, if you already know HTML (or want to learn!) you can also work directly with HTML tags to achieve any level of customization you want.
And these approaches are by no means exclusive: you can mix high-level functions with low-level HTML as much as you like.

### Utility classes

Learn more at <https://rstudio.github.io/bslib/articles/theming.html#utility-classes-1>.

### Divs

You can still customise the inputs and outputs that don't have a `class` argument; you just have to wrap them in a `<div>` first.
A `<div>` is an HTML element that can wrap any other element (or elements).
It doesn't have any appearance by default (so won't usually change the appearance of your app), but you can apply classes to it to adjust margins, padding, and background colour.
